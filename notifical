#!/bin/bash

set -u
set -e

# Script variables
declare -r today=$(date "+%d/%m")
declare -a months days targetMonths targetDays
declare week output=""
declare dateRegex="([1-9]|0[1-9]|[1-2][0-9]|3[0-1])[\/](0[1-9]|[1-2][0-2]|[1-9])"

# User variables
declare calendar=$(cal 2022 -n 3 -m --color=never)
declare -a targetDates=()
declare -r defaultColor="red"


# Miscellanous variables
RED='\033[0;31m'
YEL='\033[0;33m'
NC='\033[0m'

usage="\
${RED}Usage${NC}:
  ./$(basename "$0") [option...] [dates...]

${RED}Options${NC}:
   -n, --months       show number of months from current the month to a range of 1 to 3
   -i, --input-file   take DATE PATTERNS from file and highlight them on calendar
   -l, --list-colors  print list of available colors for highlighting"

datesExample="\
   Example: ./$(basename "$0") ${YEL}\"dd/mm color\"${NC}"

listColors="\
${RED}List of colors${NC}:
    black, white, gray, silver, lime
    red, purple, green, maroon, yellow
    olive, navy, blue, teal, aqua."

moreInfo="
Try \`$(basename "$0") -h\` for more information."

colorize() {
    echo -e "\n--------------\n"
    echo "- colorize()"
    echo "- targetDates=(${targetDates[@]})"
    #exit 22
    parseTargetDay

    for ((i = 0; i < ${#months[@]}; i++)); do
	for ((j = 0; j < ${#targetDates[@]}; j++)); do
	    mon=$(echo -n "${months[$i]}" | awk '{print $1}')
	    if [[ "$mon" == "${targetMonths[j]}" ]]; then
		sedComm="s/\b${targetDays[j]}/<b><span color=\"${color[j]}\">${targetDays[j]}<\/span><\/b>/"
		#echo "${days[i]}" | sed "s/\<${targetDays[j]}\>/<b><span color=\\\\\"${color}\\\\\">${targetDays[j]}<\/span><\/b>/"
		days[$i]=$(echo "${days[$i]}" | sed "$sedComm")
	    fi
	done
    done
    
    unset targetDates targetMonths targetDays
}

parseTargetDay() {
    local formatDate temp targetDatesTemp 
    for (( i = 0; i < ${#targetDates[@]}; i++)); do
	local date=$(echo "${targetDates[$i]}" | awk '{print $1}')
	color[$i]=$(echo "${targetDates[$i]}" | awk '{print $2}')

	IFS='/' read -a temp <<< $date

	# Reverse array from mm/dd to dd/mm
	aux=${temp[0]#0}
	temp[0]=${temp[1]}
	temp[1]=$(printf "%02d" "$aux")
	targetDatesTemp[$i]=${temp[*]}
    done

    
    for (( i = 0; i < ${#targetDatesTemp[@]}; i++)); do
	formatDates+=($(echo "0000${targetDatesTemp[$i]}" | sed 's/ //g'))
    done

    # '00001115 = November 15 0000'
    for (( i = 0; i < ${#formatDates[@]}; i++)); do
	targetMonths[$i]=$(date -d "${formatDates[$i]}" '+%B %d' | awk '{print $1}')
	targetDays[$i]=$((10#$(echo "${targetDatesTemp[$i]}" | awk ' { print $2 } ') + 0))
    done

    unset temp
}

trimMonths() {
    months=$(
	echo -n "$1" | head -1 |
	    sed 's/^[[:space:]]*//' | rev | sed 's/   */,/2g' | rev
	  ) && IFS=',' read -a months <<<$months
}

trimWeek() {
    week=$(echo "$1" | sed -n "2p" | cut -c 1-20)
}

trimNdays() {
    local temp=$(echo "$1" | tail -n +3) range=22

    for i in $(seq 1 $((${#months[@]}))); do
	days[i - 1]=$(
	    echo "$temp" |
		awk -v i="$i" -v j="$range" '{ print substr($0, 1+j*(i-1), 21) }'
	    )
    done
}

formatCalendar() {
    trimMonths "$calendar"
    trimWeek "$calendar"
    trimNdays "$calendar"
}

formatOutput() {
    local lineCount=$(echo "${days[0]}" | wc -l | awk '{ print $1 }')
    local outputMonths outputMonth="" outputWeek="" outputDays=""
    local whitespaceSeparator="    "

    # Get boundaries into variable and print the first line MONTHS
    for (( i = 0; i < ${#months[@]}; i++)); do
	# Format month section
	local trailingWhitespace="" leadingWhitespace=""
	local monthLength=$(echo "${months[$i]}" | xargs) weekLength="${#week}"

	for (( j = 0; j < "${#monthLength}"/4+1; j++ )); do
	    trailingWhitespace="$trailingWhitespace "
	done

	monthLength="$trailingWhitespace$monthLength" && monthLength="${#monthLength}"
	local leadingWhitespaceLen=$(($weekLength - $monthLength))

	for (( j = 0; j < leadingWhitespaceLen; j++ )); do
	    leadingWhitespace="$leadingWhitespace "
	done

	outputMonth="$trailingWhitespace${months[$i]}$leadingWhitespace$whitespaceSeparator"
	outputMonths+=$(echo -n "$outputMonth")

	if (( $i == ${#months[@]}-1 )); then
	    local trail=${outputMonths##*[^[:blank:]]}
	    outputMonths="${outputMonths%${trail}}"
	fi

	# Format week section
	[ -z "$outputWeek" ] && outputWeek="$week" || outputWeek="$outputWeek$whitespaceSeparator$week"
    done

    # Format days section
    local daysLineCount=$(($(echo "${days[0]}" | wc -l)))
    for (( j = 1; j <= $daysLineCount; j++)); do
	for (( k = 0; k < ${#months[@]}; k++)); do
	    line=$(echo "${days[k]}" | sed -n "$j p")

	    ! [[ "${line: -1}" == '>' ]] && (( "${#line}" > 20 )) && line="${line::-1}"

	    if [ $((k+1)) == ${#months[@]} ]; then
		outputDays="$(echo "$outputDays$line" )"
		continue
	    fi

	    outputDays="$(echo "$outputDays$line$whitespaceSeparator" )"
	    
	done
	outputDays="$outputDays\n"
    done
    output=$(echo -e "${outputMonths}\n\n${outputWeek}\n${outputDays}")
}


parseMonthNumbers() {
    local number="$1"
    local numberUsage=$(echo -e "$usage" | grep "months") && numberUsage="   ${RED}Usage${NC}:\n   $numberUsage"

    if ! [[ $number =~ ^[0-9]+$ ]]; then
	# TODO: Send to argErr
        printf "${RED}ERROR${NC}: '%s' is not a number\n" "$number"
	echo -e "$numberUsage"
	exit 1
    fi

    if [ "$number" -lt 1 ] || [ "$number" -gt 3 ]; then
	# TODO: Send to argErr
        printf "${RED}ERROR${NC}: '%s' is not between 1-3\n" "$number"
	echo -e "$numberUsage"
	exit 1
    fi

    calendar=$(cal 2022 -n $number -m --color=never)
}

parseArgumentDate() {
    local argRegex="${dateRegex}( +[a-zA-Z]+) *"
    local oneWordRegex="(^ +[^ ]+$)|(^[^ ]+$)|(^[^ ]+ +$)|(^ +[^ ]+ +$)"

    echo "- parseArgumentDate()"

    local arg="$1"
    
    # If arg matches regex "mm/xx color"
    if [[ $arg =~ $argRegex ]]; then
	echo "- $arg Matches regex [mm/xx color]"
	local argColor=$(echo "$arg" | awk '{ print $2 }')

	# Check if arg has a valid color
	if isColor "$argColor"; then
	    echo "- $argColor is a valid color"
	    echo "- adding [$arg] to targetDates"
	    targetDates+=("$arg")
	else
	    argErr "c" "$argColor"
	fi

    elif [[ $arg =~ $oneWordRegex ]]; then
	# Check if arg has only 1 word
	echo "- [$arg] is one word"
	argErr "c" "$arg"
    else
	echo "- [$arg] DOESN'T match regex [mm/xx color]"
	argErr "a" "$arg"
    fi
}

parseInputFile() {
    local fileColor="$defaultColor";
    local inputFile="$1"
    echo "- Checking if [$1] is a valid file"
    ! isFile "$1" && argErr "f" "$inputFile"
    echo -e "\n----------------------------\n"

    if isSet "$2"; then
	if isColor "$2"; then
	   echo "- [$2] is a valid color after input_file"
           fileColor="$2"  # || argErr "c" "$2"
	   echo "- [$2] added to [\$fileColor]"
           echo -e "\n----------------------------\n"
	   
	else
	   echo "- [$2] is an argument"
	   parseArgumentDate "$2"
	fi
    fi

    echo "- Now is parsing all file dates and adding default color or given color"
    echo "- [\$targetDates=(${targetDates[@]})]"

    ! [[ -f $inputFile ]] && argErr "f" "$inputFile"

    local fileDates=$(cat $inputFile | grep -E -o --color=never "$dateRegex" | sed -e "s/$/ $fileColor/")

    
    readarray -t -O "${#targetDates[@]}" targetDates <<< "$fileDates"

    echo "- [\$targetDates=(${targetDates[@]})]"

    return 0
}

isSet() {
    ! [[ -z "$1" ]]
}

isColor() {
    matchColor=$(echo "$1" | xargs)

    declare -a availableColors=(
	black white gray silver maroon
	red purple fushsia green lime
	olive yellow navy blue teal aqua)

    for (( i = 0; i < ${#availableColors[@]}; i++ )); do
	[ "$matchColor" == "${availableColors[i]}" ] && return 0
    done

    return 1
}

isFile() {
    [[ -f "$1" ]]
}

argErr() {
    errCode="$1"
    errStr=$(echo "$2" | xargs)

    printf "${RED}ERROR${NC}: "

    case "$errCode" in
	a)     echo -e "\`$errStr\` Invalid date argument\n $datesExample"      ;;
	u)     echo -e "\`$errStr\` Unexpected argument\n $datesExample"        ;;
	c)     echo -e "\`$errStr\` Is not a supported color.\n $listColors"    ;;
	f)     echo -e "\`$errStr\` Is not a valid file" && grep="--input-file" ;;
	i)     echo -e "Expected input file."       && grep="--input-file"      ;;
	n)     echo -e "Expected a range of months" && grep="--months"          ;;
    esac

    ! [[ -z "${grep+x}" ]] &&
       echo -e "$usage" | grep -E "Usage|$grep" | awk '{print "   "$0}'

    echo "$moreInfo"

    exit 1
}

# Format calendar style and trim each individual piece into separated variables
formatCalendar "$calendar"

# Parse arguments
set +u
while [[ "$#" -gt 0 ]]; do
    if ! [[ -z "$@" ]]; then
	if [[ $1 == "-h" || $1 == "--help" ]]; then
	    echo -e "Notify calendar and day reminder\n\n$usage" && exit 0
	elif [[ $1 == "-n" || $1 == "--months" ]]; then
	    ! isSet "$2" && argErr "n" || parseMonthNumbers "$2" && shift

	elif [[ $1 == "-l" || $1 == "--list-colors" ]]; then
	    echo -e "$listColors" && exit 0

	elif [[ "$1" == "-i" || $1 == "--input-file" ]]; then
	    if isSet "$2"; then
                isFile "$2" || argErr "f" "$2"
		if isSet "$3"; then
		    parseInputFile "$2" "$3"
		    shift
		else
		    parseInputFile "$2"
		fi
	    else
		argErr "i" "$2"
	    fi

	    # TODO: Positional arguments
	    shift
	    
	elif [[ $1 =~ ${dateRegex} ]]; then
	    parseArgumentDate "$1"
	else
	    argErr "u" "$1"
	fi
    fi
    shift
done
set -u

# Format calendar
formatCalendar "$calendar"

# Colorize days in calendar
targetDates+=("$today yellow")

(( ${#targetDates[@]} )) && colorize

# Format output to notify-send
formatOutput "$output"

notify-send -u low "Notifical" "$output"

exit 0
